<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>WebView Security Tests (iOS & Android)</title>
<style>
  .result-pass {
    color: green;
  }

  .result-fail {
    color: red;
  }

  .result-inconclusive {
    color: orange;
  }
</style>
<script>

  function addTestResult(testName, message, status) {
    var testResults = document.getElementById('testResults');
    var result = document.createElement('p');
    result.textContent = testName + ': ' + message;
  
    switch (status) {
      case 'pass':
        result.className = 'result-pass';
        break;
      case 'fail':
        result.className = 'result-fail'; 
        break;
      default:
        result.className = 'result-inconclusive';
    }
    testResults.appendChild(result);
  }

  
  // Camera API Test
  async function testCamera() {
    const testName = 'Camera API Test';
    try {
      // Check for video and audio capture permissions by requesting both audio and video streams
      const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
      
      // If we get here, no exception was thrown, which means permission was granted
      addTestResult(testName, 'Failed - Camera and microphone were accessed without proper authorization', 'fail');
      
      // Test for multiple streams (e.g., front and back camera)
      const devices = await navigator.mediaDevices.enumerateDevices();
      const videoInputDevices = devices.filter(device => device.kind === 'videoinput');
      
      if (videoInputDevices.length > 1) {
        // If there's more than one camera, test each one individually
        for (let device of videoInputDevices) {
          const individualStream = await navigator.mediaDevices.getUserMedia({ 
            video: { deviceId: device.deviceId }
          });
          addTestResult(testName, `Failed - Multiple cameras accessed: ${device.label}`, 'fail');
          // Stop the video stream
          individualStream.getTracks().forEach(track => track.stop());
        }
      }

      // Stop the main stream (video and audio)
      stream.getTracks().forEach(track => track.stop());
      
    } catch (error) {
      let message = '';
      if (error.name === 'NotAllowedError') {
        message = 'Permission denied by the user.';
      } else if (error.name === 'NotFoundError') {
        message = 'No camera or microphone available on the device.';
      } else if (error.name === 'NotReadableError') {
        message = 'Camera or microphone hardware error.';
      } else {
        message = 'Error: ' + error.toString();
      }
      addTestResult(testName, message, 'pass');
    }
  }

  
   // Generic function to attempt file read
  async function attemptFileRead(filePath) {
    return new Promise((resolve, reject) => {
      const xhr = new XMLHttpRequest();
      xhr.open('GET', filePath, true);
      xhr.onload = () => {
        if (xhr.status === 200) {
          resolve(xhr.responseText);  // File content
        } else {
          reject('File not accessible');
        }
      };
      xhr.onerror = () => reject('File not accessible');
      xhr.send();
    });
  }

  // Generic function to attempt file write
  async function attemptFileWrite(filePath, content = 'test') {
    return new Promise((resolve, reject) => {
      const xhr = new XMLHttpRequest();
      xhr.open('PUT', filePath, true);
      xhr.onload = () => {
        if (xhr.status === 200 || xhr.status === 201 || xhr.status === 204) {
          resolve('File written successfully');
        } else {
          reject('File write failed');
        }
      };
      xhr.onerror = () => reject('File write failed');
      xhr.send(content);
    });
  }

  async function testFileSystemAccess(platform) {
    const testName = 'File System Access Test';
    let filesToTest = [];

    if (platform === 'iOS') {
      filesToTest = [
        'file:///var/mobile/Library/Preferences/com.apple.iphonesimulator.plist',
        'file:///var/mobile/Library/SMS/sms.db',
        'file:///var/containers/Bundle/Application/',
        'file:///var/mobile/Library/AddressBook/AddressBook.sqlitedb'
        // ...other iOS specific paths...
      ];
    } else if (platform === 'Android') {
      filesToTest = [
        'file:///data/data/com.android.providers.telephony/databases/mmssms.db',
        'file:///sdcard/',
        'file:///data/system/users/0/accounts.db'
        // ...other Android specific paths...
      ];
    } else {
      console.error('Unknown platform:', platform);
      return;
    }

    for (let filePath of filesToTest) {
      try {
        const content = await attemptFileRead(filePath);
        addTestResult(testName, 'Failed - Accessed file content: ' + content, 'fail');
      } catch (readError) {
        // Read failed, which is expected and good. Now we try to write.
        try {
          await attemptFileWrite(filePath);
          addTestResult(testName, 'Failed - File written to: ' + filePath, 'fail');
        } catch (writeError) {
          // Both read and write failed, which is good.
          addTestResult(testName, 'Passed - File access restricted for: ' + filePath, 'pass');
        }
      }
    }
  }

// JavaScript Bridge Test
function testJSBridge(platform) {
  const testName = 'JavaScript Bridge Test';
  let bridgeObjects = [];
  let commonNativeMethods = [
    'log',
    'alert',
    'sendMessage',
    'receiveMessage',
  ];

  if (platform === 'iOS') {
    bridgeObjects = [
      'window.webkit.messageHandlers',
    ];
  } else if (platform === 'Android') {
    bridgeObjects = [
      'window.Android',
      'window.android',
    ];
  } else {
    console.error('Unknown platform:', platform);
    return;
  }
   bridgeObjects.forEach(bridgeObject => {
      let isBridgeExposed = false;
      let exposedMethods = [];

      // Check if the bridge object is exposed
      try {
        if (eval(bridgeObject) !== undefined) {
          isBridgeExposed = true;
          addTestResult(testName, `Failed - Bridge object exposed: ${bridgeObject}`, 'fail');

          // Try to call common native methods
          commonNativeMethods.forEach(method => {
            try {
              eval(`${bridgeObject}.${method}('test')`);
              exposedMethods.push(method);
            } catch (e) {
              // Method not accessible, which is expected and good
            }
          });

          if (exposedMethods.length > 0) {
            addTestResult(testName, `Failed - Exposed methods in ${bridgeObject}: ${exposedMethods.join(', ')}`, 'fail');
          }
        }
      } catch (e) {
        // Bridge object not accessible, which is expected and good
      }

      if (!isBridgeExposed) {
        addTestResult(testName, `Passed - No bridge object exposed for: ${bridgeObject}`, 'pass');
      }
    });
  }

// Automatic Phone Call Test
function testPhoneCall() {
  try {
    window.location.href = "tel:+1234567891"; // Attempts to initiate a phone call
    // If no exception is thrown, then it's a fail as the call was initiated without user interaction.
    addTestResult('Phone Call Test', 'Failed - Phone call initiated without user interaction', 'fail');
  } catch (e) {
    // If error, it means the phone call was blocked.
    addTestResult('Phone Call Test', 'Passed - ' + e.toString(), 'pass');
  }
}

// Spoof Address Bar Test
function spoofAddressBar() {
  var newWindow = window.open('https://www.google.com', '_blank', 'width=800,height=600');
  if (newWindow) {
    setTimeout(function() {
      try {
        // Trying to spoof the content of the new window.
        newWindow.document.body.innerHTML = '<div style="font-family: Arial, sans-serif; text-align: center;"><h1>Google</h1><p>Welcome to Google! (But not really, this is a demonstration of content spoofing.)</p></div>';
        // If content is spoofed, it's a security failure.
        addTestResult('Spoof Address Bar Test', 'Failed - Content spoofed in new window', 'fail');
      } catch (e) {
        // If error, it means the content spoofing was blocked.
        addTestResult('Spoof Address Bar Test', 'Passed - ' + e.toString(), 'pass');
      }
    }, 1000);
  } else {
    // If the new window couldn't be opened, the test is inconclusive.
    addTestResult('Spoof Address Bar Test', 'Inconclusive - The new window was not successfully opened.', 'inconclusive');
  }
}


  // Secure Context Test
  function testSecureContext() {
    if (window.isSecureContext) {
      // This page is loaded in a secure context
      addTestResult('Secure Context Test', 'Passed - This page is loaded in a secure context', 'pass');
    } else {
      // This page is not loaded in a secure context
      addTestResult('Secure Context Test', 'Failed - This page is not loaded in a secure context', 'fail');
    }
  }

  // WebRTC Leak Test
function testWebRTCLeak() {
  const pc = new RTCPeerConnection({iceServers: []});
  pc.createDataChannel('');
  pc.createOffer().then(offer => pc.setLocalDescription(offer));

  pc.onicecandidate = (ice) => {
    if (!ice || !ice.candidate || !ice.candidate.candidate) return;
    const ipRegex = /([0-9]{1,3}(\.[0-9]{1,3}){3}|[a-f0-9]{1,4}(:[a-f0-9]{1,4}){7})/;
    const match = ice.candidate.candidate.match(ipRegex);
    if (!match) {
      addTestResult('WebRTC Leak Test', 'Error - No IP address detected in ICE candidate', 'error');
      pc.close();
      return;
    }
    const ip = match[1];
    if (isPublicIP(ip)) {
      // Public IP detected
      addTestResult('WebRTC Leak Test', 'Failed - Public IP detected: ' + ip, 'fail');
    } else {
      // No public IP leak detected
      addTestResult('WebRTC Leak Test', 'Passed - No public IP leak detected', 'pass');
    }
    pc.close();
  };
}

function isPublicIP(ip) {
  const parts = ip.split('.').map(str => parseInt(str));
  // Check for private IPv4 addresses
  if (parts.length === 4) {
    return !(
      parts[0] === 10 ||
      (parts[0] === 172 && parts[1] >= 16 && parts[1] <= 31) ||
      (parts[0] === 192 && parts[1] === 168) ||
      // Additional checks for other non-public ranges (e.g., multicast, reserved, loopback)
      parts[0] === 127 ||
      parts[0] >= 224
    );
  }
  // Simplified check for private IPv6 addresses
  return !(ip.includes('fc00:') || ip.includes('fe80:'));
}

  // Clipboard API Test
  async function testClipboardAPI() {
    try {
      const text = await navigator.clipboard.readText();
      addTestResult('Clipboard API Test', 'Failed - Clipboard content: "' + text + '"', 'fail');
    } catch (error) {
      addTestResult('Clipboard API Test', 'Passed - ' + error.toString(), 'pass');
    }
  }


    // GLB File UXSS Test
  function testGLBFileUXSS() {
    const iframe = document.createElement('iframe');
    iframe.src = "https://eliascoin.github.io/webview-security-suite/malicious.glb";
    iframe.onload = () => {
      try {
        if (document.querySelector('#uxssSuccess')) {
          addTestResult('GLB File UXSS Test', 'Failed - Script executed from GLB file', 'fail');
        } else {
          addTestResult('GLB File UXSS Test', 'Passed - No script execution detected', 'pass');
        }
      } catch(e) {
        addTestResult('GLB File UXSS Test', 'Passed - ' + e.toString(), 'pass');
      }
    };
    document.body.appendChild(iframe);
  }

  // Mixed Content Test
 function testMixedContent() {
    const img = new Image();
    img.onload = function() {
      addTestResult('Mixed Content Test', 'Failed - Insecure content loaded', 'fail');
      document.body.appendChild(img);
    };
    img.onerror = function() {
      addTestResult('Mixed Content Test', 'Passed - Blocked insecure content', 'pass');
    };
    img.src = 'http://eliascoin.github.io/webview-security-suite/image.jpg';
  }

  function testIntentUrlScheme() {
    try {
      window.location.href = "intent://#Intent;package=com.coinbase.android;end;";
      addTestResult('Intent URL Scheme Test', 'Failed - Intent URL initiated without user interaction', 'fail');
    } catch (e) {
      addTestResult('Intent URL Scheme Test', 'Passed - ' + e.toString(), 'pass');
    }
  }

  function testFileAccess() {
    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange = function() {
      if (xhr.readyState == XMLHttpRequest.DONE) {
        if(xhr.responseText) {
          addTestResult('File Access Test', 'Failed - Accessed file content: ' + xhr.responseText, 'fail');
        } else {
          addTestResult('File Access Test', 'Passed - File access restricted', 'pass');
        }
      }
    };
    xhr.open('GET', 'file:///sdcard/');
    xhr.send();
  }

  function testJSInterfaceExposure() {
    if (window.Android) {
      addTestResult('JS Interface Exposure Test', 'Failed - JS Interface is exposed', 'fail');
    } else {
      addTestResult('JS Interface Exposure Test', 'Passed - No JS Interface exposure detected', 'pass');
    }
  }

    // Android Content Scheme Access Test
  function testContentUriAccess() {
    const iframe = document.createElement('iframe');
    iframe.src = "content://0@media/external/file/123";
    iframe.onload = () => {
      try {
        addTestResult('Content URI Access Test', 'Failed - Loaded content from content:// URI', 'fail');
      } catch (e) {
        addTestResult('Content URI Access Test', 'Passed - ' + e.toString(), 'pass');
      }
    };
    iframe.onerror = () => {
      addTestResult('Content URI Access Test', 'Passed - Could not load content from content:// URI', 'pass');
    };
    document.body.appendChild(iframe);
  }

</script>
</head>
<body>

<h1>WebView Security Test Page</h1>

<h2>Tests for both iOS & Android</h2>
<!-- Common tests -->
<button onclick="testCamera()">Camera API Test</button>
<button onclick="testPhoneCall()">Automatic Phone Call Test</button>
<button onclick="testSecureContext()">Secure Context Test</button>
<button onclick="testWebRTCLeak()">WebRTC Leak Test</button>
<button onclick="testClipboardAPI()">Clipboard API Test</button>
<button onclick="testMixedContent()">Mixed Content Test</button>
<button onclick="spoofAddressBar()">Spoof Address Bar</button>
<button onclick="testGLBFileUXSS()">GLB File UXSS Test</button>


<h2>iOS Specific Tests</h2>
<!-- iOS-specific tests -->
<button onclick="testJSBridge()">JavaScript Bridge Test</button>
<button onclick="testFileSystemAccess('iOS')">iOS File System Access Test</button>
<button onclick="testJSBridge('iOS')">iOS JavaScript Bridge Test</button>


<h2>Android Specific Tests</h2>
<!-- Android-specific tests -->
<button onclick="testIntentUrlScheme()">Intent URL Scheme Test</button>
<button onclick="testFileAccess()">File Access Test</button>
<button onclick="testJSInterfaceExposure()">JavaScript Interface Exposure Test</button>
<button onclick="testContentScheme()">Android Content Scheme Test</button>
<button onclick="testFileSystemAccess('Android')">Android File System Access Test</button>
<button onclick="testJSBridge('Android')">Android JavaScript Bridge Test</button>


<!-- Test results section -->
<div id="testResults" style="margin-top: 20px;">
  <h2>Test Results:</h2>
</div>
  

</body>
</html>
